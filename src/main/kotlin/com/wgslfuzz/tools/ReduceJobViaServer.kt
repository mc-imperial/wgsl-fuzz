/*
 * Copyright 2025 The wgsl-fuzz Project Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.wgslfuzz.tools

import com.wgslfuzz.core.AstWriter
import com.wgslfuzz.core.ShaderJob
import com.wgslfuzz.semanticspreservingtransformations.reduce
import com.wgslfuzz.utils.IdenticalImageCompare
import io.ktor.client.HttpClient
import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.default
import kotlinx.cli.required
import kotlinx.serialization.json.Json
import java.io.File
import java.io.FileOutputStream
import java.io.PrintStream
import java.nio.file.Path
import java.util.concurrent.atomic.AtomicInteger

fun main(args: Array<String>) {
    val username =
        System.getenv("WGSL_FUZZ_ADMIN_USERNAME")
            ?: error("Environment variable WGSL_FUZZ_ADMIN_USERNAME not set")
    val password =
        System.getenv("WGSL_FUZZ_ADMIN_PASSWORD")
            ?: error("Environment variable WGSL_FUZZ_ADMIN_PASSWORD not set")

    val parser = ArgParser("Tool for reducing a shader job via a server")

    val serverUrl by parser
        .option(
            ArgType.String,
            fullName = "serverUrl",
            description = "URL of the server",
        ).required()

    val jobFile by parser
        .option(
            ArgType.String,
            fullName = "jobFile",
            description = "Path to a shader job to be reduced",
        ).required()

    val workerName by parser
        .option(
            ArgType.String,
            fullName = "workerName",
            description = "The name of the worker that should execute jobs",
        ).required()

    val outputDir by parser
        .option(
            ArgType.String,
            fullName = "outputDir",
            description = "Directory to write output files",
        ).required()

    val repetitions by parser
        .option(
            ArgType.Int,
            fullName = "repetitions",
            description = "Number of repeat runs of each job",
        ).default(1)

    val timeoutMillis by parser
        .option(
            ArgType.Int,
            fullName = "timeoutMillis",
            description = "Timeout in milliseconds",
        ).default(60 * 1000)

    val developerMode by parser
        .option(
            ArgType.Boolean,
            fullName = "developerMode",
            description = "Enable developer mode",
        ).default(false)

    val expectedOutputText by parser
        .option(
            ArgType.String,
            fullName = "expectedOutputText",
            description = "Text expected in the output for it to be deemed interesting",
        )

    val referenceImage by parser
        .option(
            ArgType.String,
            fullName = "referenceImage",
            description = "Reference image for bad image reduction",
        )

    val nonDeterministic by parser
        .option(
            ArgType.Boolean,
            fullName = "nonDeterministic",
            description = "Check for non determinism for it to be deemed interesting",
        ).default(false)

    val noImageGenerated by parser
        .option(
            ArgType.Boolean,
            fullName = "noImageGenerated",
            description = "Check for no image to be generated to be deemed interesting",
        ).default(false)

    parser.parse(args)

    println("Parsing shader job from file")
    val shaderJob = Json.decodeFromString<ShaderJob>(File(jobFile.removeSuffix(".wgsl") + ".shaderjob.json").readText())
    println("Parsing complete")

    val compareOn =
        if (expectedOutputText != null && referenceImage == null && !nonDeterministic && !noImageGenerated) {
            CompareOn.ExpectedOutputText(expectedOutputText!!)
        } else if (expectedOutputText == null && referenceImage != null && !nonDeterministic && !noImageGenerated) {
            CompareOn.ReferenceImage(referenceImage!!)
        } else if (expectedOutputText == null && referenceImage == null && nonDeterministic && !noImageGenerated) {
            CompareOn.NonDeterminism
        } else if (expectedOutputText == null && referenceImage == null && !nonDeterministic && noImageGenerated) {
            CompareOn.NoImageGenerated
        } else {
            throw IllegalArgumentException("Did not set expectedOutputText, referenceImage and nonDeterministic correctly")
        }

    createClient(
        developerMode = developerMode,
        username = username,
        password = password,
    ).use { httpClient ->
        println("Checking that original shader job is interesting")
        if (!isInteresting(
                shaderJob = shaderJob,
                jobFilename = "original.wgsl",
                reductionWorkDir = outputDir,
                serverUrl = serverUrl,
                httpClient = httpClient,
                repetitions = repetitions,
                workerName = workerName,
                timeoutMillis = timeoutMillis,
                compareOn = compareOn,
            )
        ) {
            throw RuntimeException("Original shader job not interesting.")
        }
        println("Original shader job is interesting!")

        AstWriter(
            out = PrintStream(FileOutputStream(File(outputDir, "original_annotated.wgsl"))),
            emitCommentary = true,
        ).emit(
            shaderJob.tu,
        )

        val counter = AtomicInteger(0)
        val reductionResult =
            shaderJob.reduce { candidate: ShaderJob ->
                isInteresting(
                    shaderJob = candidate,
                    jobFilename = "candidate${counter.getAndIncrement()}.wgsl",
                    reductionWorkDir = outputDir,
                    serverUrl = serverUrl,
                    httpClient = httpClient,
                    workerName = workerName,
                    timeoutMillis = timeoutMillis,
                    repetitions = repetitions,
                    compareOn = compareOn,
                )
            }
        reductionResult?.let { (simplest, maybeSimplerButNotInteresting) ->
            val prettyJson = Json { prettyPrint = true }
            AstWriter(
                out = PrintStream(FileOutputStream(File(outputDir, "simplest.wgsl"))),
            ).emit(simplest.tu)
            AstWriter(
                out = PrintStream(FileOutputStream(File(outputDir, "simplest_annotated.wgsl"))),
                emitCommentary = true,
            ).emit(simplest.tu)
            File(outputDir, "simplest.shaderjob.json").writeText(prettyJson.encodeToString(simplest))

            maybeSimplerButNotInteresting?.let { simplerButNotInteresting ->
                AstWriter(
                    out = PrintStream(FileOutputStream(File(outputDir, "simpler_but_not_interesting.wgsl"))),
                ).emit(simplerButNotInteresting.tu)
                AstWriter(
                    out = PrintStream(FileOutputStream(File(outputDir, "simpler_but_not_interesting_annotated.wgsl"))),
                    emitCommentary = true,
                ).emit(simplerButNotInteresting.tu)
                File(outputDir, "simpler_but_not_interesting.shaderjob.json").writeText(prettyJson.encodeToString(simplerButNotInteresting))
            }
        }
    }
}

private fun isInteresting(
    shaderJob: ShaderJob,
    jobFilename: String,
    reductionWorkDir: String,
    serverUrl: String,
    workerName: String,
    httpClient: HttpClient,
    repetitions: Int,
    timeoutMillis: Int,
    compareOn: CompareOn,
): Boolean {
    val prettyJson = Json { prettyPrint = true }

    AstWriter(
        PrintStream(
            FileOutputStream(
                File(
                    reductionWorkDir,
                    jobFilename,
                ),
            ),
        ),
    ).emit(shaderJob.tu)
    File(
        reductionWorkDir,
        jobFilename.removeSuffix(".wgsl") + ".uniforms.json",
    ).writeText(prettyJson.encodeToString(shaderJob.getByteLevelContentsForUniformBuffers()))
    File(
        reductionWorkDir,
        jobFilename.removeSuffix(".wgsl") + ".shaderjob.json",
    ).writeText(prettyJson.encodeToString(shaderJob))
    runJobViaServer(
        job = File(reductionWorkDir, jobFilename),
        serverUrl = serverUrl,
        httpClient = httpClient,
        repetitions = repetitions,
        workerName = workerName,
        timeoutMillis = timeoutMillis,
        outputDirPath = Path.of(reductionWorkDir),
    )

    if (!compareOn.checkInteresting(reductionWorkDir, jobFilename)) {
        return false
    }

    File(reductionWorkDir, "best_so_far.txt").writeText(
        Path.of(reductionWorkDir).resolve(jobFilename).toString(),
    )
    return true
}

private sealed interface CompareOn {
    fun checkInteresting(
        reductionWorkDir: String,
        jobFilename: String,
    ): Boolean

    class ExpectedOutputText(
        private val text: String,
    ) : CompareOn {
        override fun checkInteresting(
            reductionWorkDir: String,
            jobFilename: String,
        ): Boolean = text in File(reductionWorkDir, jobFilename.removeSuffix(".wgsl") + ".result.json").readText()
    }

    class ReferenceImage(
        private val referenceImagePath: String,
    ) : CompareOn {
        override fun checkInteresting(
            reductionWorkDir: String,
            jobFilename: String,
        ): Boolean {
            if (NonDeterminism.checkInteresting(reductionWorkDir, jobFilename)) {
                // Nondeterministic output
                return false
            }
            val resultImage = jobFilename.removeSuffix(".wgsl") + ".png"
            if (!File(reductionWorkDir, resultImage).exists()) {
                // No image - not interesting
                return false
            }
            val referenceImageFile = File(referenceImagePath)
            val resultImageFile = File(reductionWorkDir, resultImage)

            // TODO(https://github.com/mc-imperial/wgsl-fuzz/issues/191)
            if (IdenticalImageCompare.equivalentImages(referenceImageFile, resultImageFile)) {
                // Identical images - not interesting
                return false
            }
            return true
        }
    }

    object NonDeterminism : CompareOn {
        override fun checkInteresting(
            reductionWorkDir: String,
            jobFilename: String,
        ): Boolean = File(reductionWorkDir, jobFilename.removeSuffix(".wgsl") + ".nondet").exists()
    }

    object NoImageGenerated : CompareOn {
        override fun checkInteresting(
            reductionWorkDir: String,
            jobFilename: String,
        ): Boolean {
            if (NonDeterminism.checkInteresting(reductionWorkDir, jobFilename)) {
                // Nondeterministic output
                return false
            }
            val resultImage = jobFilename.removeSuffix(".wgsl") + ".png"
            return !File(reductionWorkDir, resultImage).exists()
        }
    }
}

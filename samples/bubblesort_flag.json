{
    "uniformBuffers": [
        {
            "binding": 0,
            "group": 0,
            "data": [
                0,
                0,
                0,
                0,
                0,
                0,
                128,
                63,
                0,
                1,
                0,
                0,
                0,
                1,
                0,
                0
            ]
        }
    ],
    "shaderText": "struct Uniforms {\n  injectionSwitch: vec2f,\n  resolution: vec2<i32>,\n}\n\n@group(0)\n@binding(0)\nvar<uniform> ub: Uniforms;\n\n@vertex\nfn vertexMain(@location(0) pos: vec2f) -> @builtin(position) vec4f {\n  return vec4f(pos, 0, 1);\n}\n\nfn checkSwap(gl_FragCoord: vec4f, a: f32, b: f32) -> bool\n{\n    return select((a < b), (a > b), gl_FragCoord.y < f32(ub.resolution.y) / 2.0);\n}\n\n@fragment\nfn fragmentMain(\n  @builtin(position) gl_FragCoord: vec4f,\n) -> @location(0) vec4f {\n    var data: array<f32, 10>;\n    for(var i: i32 = 0; i < 10; i++) {\n        data[i] = f32(10 - i);\n    }\n    for(var i: i32 = 0; i < 9; i++) {\n        for(var j: i32 = 0; j < 10; j++) {\n            if(j < i + 1) {\n\t        continue;\n            }\n            let doSwap = checkSwap(gl_FragCoord, data[i], data[j]);\n            if(doSwap) {\n                let temp = data[i];\n                data[i] = data[j];\n                data[j] = temp;\n            }\n        }\n    }\n\n    if(gl_FragCoord.x < f32(ub.resolution.x) / 2.0) {\n        return vec4(data[0] / 10.0, data[5] / 10.0, data[9] / 10.0, 1.0);\n    }\n    else {\n        return vec4(data[5] / 10.0, data[9] / 10.0, data[0] / 10.0, 1.0);\n    }\n}\n"
}
